/*=============================================================================
    Written by Carolina P. Nogueira (2016)
=============================================================================*/
#pragma once
#include "skip_parser.hpp"
#include "bench_grammar.hpp"
#include <fstream>

#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/functional/hash.hpp>
#include <boost/unordered_map.hpp>
#include <unordered_map>
#include <stdexcept>



/*
 * Gate type strings
 *
 */
#define OUTPUT_GATE_T    "OUTPUT"
#define INPUT_GATE_T     "INPUT"
#define FLIP_FLOP_GATE_T "DFF"
#define BUFFER_GATE_T    "BUFF"
#define NOT_GATE_T       "NOT"
#define AND_GATE_T       "AND"
#define OR_GATE_T        "OR"
#define NAND_GATE_T      "NAND"
#define NOR_GATE_T       "NOR"
#define XOR_GATE_T       "XOR"

namespace std
{
    template<>
    /* Overwriting hash function for UUID */
    struct hash<boost::uuids::uuid>
    {
        size_t operator () (const boost::uuids::uuid& uid)
        {
            return boost::hash<boost::uuids::uuid>()(uid);
        }
    };
};

/* Type definitions */
typedef std::string label_t;                        ///< Type definition for labels
typedef std::string gate_type_t;                    ///< Type definition for gates
typedef bench_format::bench_node_type bench_node_t; ///< Type definition for a node of the ISCAS85/89/99 bench format
//typedef boost::uuids::uuid unique_ID_t;             ///< Type definition for unique identifiers for circuits
typedef size_t unique_ID_t;             ///< Type definition for unique identifiers for circuits
typedef std::set<unique_ID_t> set_of_circuit_t;     ///< Type definition for set of circuits

/**
 * \struct circuit_node_type
 * \brief Struct that represents a node from a circuit. 
 *
 */
typedef struct circuit_node_type
    {
        unique_ID_t ID;                  ///< Unique ID for a node
        std::string label;               ///< Node Label
        std::string gate_type;           ///< Type of the gate (ex. AND, NOT, OR)
        set_of_circuit_t input_ID_list;  ///< set containing all the inputs of the respective gate 
        set_of_circuit_t output_ID_list; ///< set containing all the outputs of the respective gate
    }circuit_node_type;

typedef std::list<circuit_node_type> list_of_circuit_t; ///< Type definition for list of circuits

/* Exceptions */
/**
 * \class SyntaxException
 * \brief This exception should be thrown when the file does not have the proper syntax.
 *
 */
class SyntaxException : public std::runtime_error {
public:
    SyntaxException(const std::string& message) : std::runtime_error(message) { };
};

/**
 * \class InexistentLabelException
 * \brief This exception should be thrown when an invalid label_t is passed as parameter.
 *
 */
class InexistentLabelException : public std::runtime_error {
public:
    InexistentLabelException(const std::string& message) : std::runtime_error(message) { };
};

/**
 * \class InexistentUUIDException
 * \brief This exception should be thrown when an invalid unique_ID_t is passed as parameter.
 *
 */
class InexistentUUIDException: public std::runtime_error {
public:
    InexistentUUIDException(const std::string& message) : std::runtime_error(message) { };
};

/**
 * \class CicleException
 * \brief This exception should be thrown when a non-cycle free circuit is parsed.
 *
 */
class CicleException: public std::runtime_error {
public:
    CicleException(const std::string& message) : std::runtime_error(message) { };
};

/**
 * \class OpenFileException
 * \brief This exception should be thrown when a file cannot be accessed.
 *
 */
class OpenFileException: public std::runtime_error {
public:
    OpenFileException(const std::string& message) : std::runtime_error(message) { };
};

/**
 * \class bench_circuit_manager
 * 
 * \brief Class to convert bench nodes into circuits nodes.
 *
 *  Bench nodes are generated by parsing ISCAS85/89/99 bench format files.
 *
 * \authors {Carolina Nogueira}
 * 
 */
class bench_circuit_manager{
    private:

		unique_ID_t ID_counter; // by mohammad
		
        /* Generator for UUIDs */
        boost::uuids::random_generator generator;       
        
        /* Mappings */
        std::set<label_t> set_of_output_labels;     ///< Set containing bench node labels of all OUTPUT gates
        std::set<label_t> set_of_flipflop_labels;   ///< Set containing bench node labels of all FLIP FLOP gates.
                                                    ///<  When a FLIP FLOP bench gate is parsed, it is splitted 
                                                    ///< into two circuit's gates: one will be handled as INPUT 
                                                    ///< gate and the other one as OUTPUT gate.
                                                    ///<
		std::set<label_t> outputs;
        
        set_of_circuit_t set_of_circuit_OUT;        ///< Set containing the unique ID of all OUTPUT gates
        set_of_circuit_t set_of_circuit_IN ;        ///< Set containing the unique ID of all INPUT gates
         
        std::unordered_map<label_t, bench_node_t> labels2node_table;                   ///< Mapping from bench node labels to bench node
        std::unordered_map<label_t, unique_ID_t>  labels2uuid_table;                   ///< Mapping from bench node labels to circuit unique IDs
        boost::unordered_map<unique_ID_t, circuit_node_type>  uuid2circuitNode_table;  ///< Mapping from circuit unique IDs to circuit nodes
        
        /* Topological Sorted Circuit */
        list_of_circuit_t sorted_circuit; ///< List contained the topological sorted circuit nodes
        
        
        
        /* --------------- 
         * Print Functions 
         * ---------------
         */       
         
        /**
         * \brief Print the labels2node_table table.
		 * \param none
		 * \return none
		 *
		 *  It prints all the labels and the data associated to bench nodes.
		 */
        void PrintLabelsTable(void);
        
        /**
         * \brief Print the uuid2circuitNode_table table.
		 * \param none
		 * \return none
		 *
		 *  It prints all the unique IDs and the data associated to circuit nodes.
		 */
        void PrintUUIDCircuitTable(void);
        
        /**
         * \brief Print the set_of_output_labels list.
		 * \param none
		 * \return none
		 *
		 * It prints the list containing the label of all output nodes.
		 */ 
        void PrintOutputList(void);

        /**
         * \brief Print the labels2uuid_table table.
		 * \param none
		 * \return none
		 *
		 *  It prints all the labels and its associates unique circuit ID.
		 */
        void PrintLabels2UUIDTable(void);
        
        /**
         * \brief prints the circuit starting from the given unique identificator.
		 * \param circuit_ID is unique_ID_t corresponding to a node circuit.
		 * \param indent is int and represents the depth of the node in the circuit.
		 * \return none
         *
         * It prints the circuit starting from circuit_ID node. Indent is an integer 
         *      corresponding to the depth of the node in the circuit. Each unity
         *      will add four spaces as identation before printing the node's data.
         *   
         */           
        void PrintCircuit(unique_ID_t circuit_ID, int indent);
        
        /**
         * \brief prints the circuit starting from the given label's node.
		 * \param node_label is label_t
		 * \return none
         *   
         */           
        void PrintCircuitByLabel(label_t node_label);
        
        /**
         * \brief prints all circuits from the set of circuit OUTPUTS.
		 * \param none
		 * \return none
         *   
         */           
        void PrintCircuitsOfOutputSet(void);       
        
        /**
         * \brief prints the list of topological sorted circuit's node.
		 * \param none
		 * \return none
         *   
         */ 
        void PrintSortedCircuitList(void);
        
        /* ---------------- 
         * Get functions
         * ----------------
         */
         
        /**
         * \brief return a list with the UUID of the INPUT gates of the circuit.
		 * \param none
		 * \return set_of_circuit_t
         *   
         */
        set_of_circuit_t GetListOfCircuitsInputs(void);
         
        /**
         * \brief return a list with the UUID of the OUTPUT gates of the circuit.
		 * \param none
		 * \return set_of_circuit_t
         *   
         */
        set_of_circuit_t GetListOfCircuitsOutputs(void);   
        
        /** 
         * \brief return a circuit node, given a its unique ID.
		 * \param circuit_node_uuid is unique_ID_t
		 * \return circuit_node_type
         *   
         */         
        circuit_node_type GetCircuitNode(unique_ID_t circuit_node_uuid);
        
        /** 
         * \brief return the table representing the circuit.
		 * \param none
		 * \return boost::unordered_map<unique_ID_t, circuit_node_type>
         *   
         */         
        boost::unordered_map<unique_ID_t, circuit_node_type> GetCircuit(void);
		/* --------------- 
         * Read File Functions 
         * ---------------
         */  
        /**
         * \brief Reads the file containing the circuit in the bench format.
		 * \param bench_file is std::string.
		 * \return bool returns true in case of success.
		 *
		 *  Reads the file containing the circuit in the bench format.
		 */
        bool ParseFile(std::string bench_file); 
        
        /* ---------------- 
         * Insert functions
         * ----------------
         */    
        
        /** 
         * \brief return the list of circuit nodes topologically sorted.
		 * \param bench_node is bench_node_t
		 * \return bool: 
		 *          true  -> Node successfully added 
         *          false -> Node already exist and could not be added
         *  
         * Adds a node to the labels table (labels2node) and to the 
         *      sets_of_outputs in case it is of gate type OUTPUT.
         *
         */ 
        bool AddToLabelsTable(bench_node_t bench_node);
                 
        /** 
         * \brief search or add the node to the circuit.
		 * \param bench_node is bench_node_t 
		 * \return unique_ID_t representing the given bench_node 
         *  
         *  It searches if the bench node exist in the label2uuid_table. 
         *  If it does't, adds it to the table and return the unique ID. 
         *  Otherwise, simply return the unique ID of the node.
         *
         */  
        unique_ID_t FindOrAddToCircuit(bench_node_t bench_node);
           
        /** 
         * \brief find or add a node to the circuit given its label.
		 * \param node_label is label_t 
		 * \return unique_ID_t representing the given label 
         *  
         *  It searches if the node corresponding to the given label is 
         *      already inserted into the labels2uuid_table table. If it is,
         *      returns its id. If not, creates a new node into the circuit 
         *      and add it to the table.
         *
         */  
        unique_ID_t FindOrAddToCircuitbyLabel(label_t node_label);      
        
        /* -------------------- 
         * Convertion functions
         * --------------------
         */   

        /** 
         * \brief converts bench node to circuit node.
		 * \param bench_node is bench_node_t and represents the node to be converted.
		 * \return circuit_node_type 
         *  
         *  Given a bench_node_t, it converts the node into an circuit_node_type.
         */
        circuit_node_type BenchNode2CircuitNode(bench_node_t bench_node);        

        /*
         * 
         * Create circuit functions
         *
         */        
         
        /** 
         * \brief create a circuit from the labels in the set_of_output_labels.
		 * \param none
		 * \return none
         *  
         */
        void CreateCircuitFromOutputList(void);

        /** 
         * \brief create a circuit from the given node's label.
		 * \param bnode_label is label_t
		 * \return none
         *  
         */
         void CreateCircuitbyLabel(label_t bnode_label);
       
         /* -----------------------------
          * Topological Sort Algorithms
          * -----------------------------
          */     

        /** 
         * \brief Implementation of Kahn's Algorithm for topological sort.
		 * \param none
		 * \return none (the result is stored at sorted_circuit variable)
         *  
         */
         void TopologicalSortKahnsAlgorithm(void);

         /* -----------------------------
          * Auxiliar functions for
          * Topological Sort Algorithms
          * -----------------------------
          */
         
         /** 
          * \brief auxiliar function for topological sort algorithms.
		  * \param src_node is unique_ID_t
		  * \param dst_node is unique_ID_t
		  * \return True if it was the only outgoing edge. False, otherwise.
          *
          * It removes the edge from src->dst at the table uuid2circuitNode and
          * then checks if it was the only outgoing edge. 
          */          
          bool IsUniqueOutgoingEdge(unique_ID_t src_node, unique_ID_t dst_node);

    public:
        /**
		* \brief Constructor 
		* \param bench_file is std::string. 
		* Constructor method for the bench_circuit_manager class. It 
		* generates the topological circuit described in the file 
		* bench_file that must be in the ISCAS85/ISCAS89/ISCAS99 format.
		*
		*/
        bench_circuit_manager(std::string bench_file);
        
        /**
		* \brief Destructor 
		* \param none
		* Destructor method for the bench_circuit_manager class.
		*
		*/
        ~bench_circuit_manager();
                
        
        /** 
         * \brief return the list of circuit nodes topologically sorted.
		 * \param none
		 * \return list_of_circuit_t
         *   
         */          
        list_of_circuit_t GetSortedCircuit(void);
        
        /**
         * \brief return a list with the labels of the OUTPUT gates of the circuit. The label's list also includes the FLIP_FLOPS
		 * \param none
		 * \return std::set<label_t>
         *   
         */
        std::set<label_t> GetListOfOutputLabels(void);
			
};
